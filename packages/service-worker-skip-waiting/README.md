# Использование

```
[packages]
  |
  |-- service-worker-skip-waiting
  |    |-- public
  |    |    |-- index.html   - содержит скрипт, исполняемый в Main-thread. Скрипт надо руками скопировать в [packages]/tests-sw-cache-skip-waiting/public/index.html
  |    |    |                  Выполняет служебные задачи, связанные с sw.
  |    |    |-- module.sw.js - зависимости, необходимые для sw.js . Здесь появляется при prod-сборке sw.
  |    |    |-- sw.js        - основной файл sw, исполняется в выделенном thread.
  |    |
  |    |-- package.json      - содержит скрипты для сборки sw.
  |
  | ...
  |
  |-- tests-sw-cache-skip-waiting
  |    |-- public
  |    |    |-- index.html
  |
```

Переменная `scope` хранит scope sw. Используется при определении имени кеша. Здесь задается вручную, чтобы было наглядно видно - этот `sw.js` работает на таком-то scope. В `[packages]/service-worker-skip-waiting/package.json` подготовлены два скрипта `dev` и `prod`.

### Скрипт `dev`

1. Собирает `module.sw.js`
2. Копирует из проекта `[packages]/service-worker-skip-waiting/` файлы `./dist/module.sw.js` и `./public/sw.js` в папку `[packages]/tests-sw-cache-skip-waiting/public`

### Скрипт `prod`

1. Собирает `module.sw.js`
2. В проекте `[packages]/service-worker-skip-waiting/` копирует файл `./dist/module.sw.js` в папку `./public`

После выполнения скрипта файлы `sw.js` и `module.sw.js` в папке `[packages]/service-worker-skip-waiting/public` готовы для деплоя.  
Осталось только не забыть прописать актуальные версии кешей в файле `sw.js`.

# Режимы работы сервис воркера

### Нормальный режим

Браузер читает `sw.js` -> запускается процесс инициализации сервис воркера: последовательно выполняется описанная в `sw.js` логика, создаются объекты, открывается соединение с IndexedDB и т.п.   
Если в sw отсутствет активность, тогда браузер может его остановить (полностью прекратить его работу). Интервалы проверки на активность зависят от браузера, например, в хроме это ~30 секунд.  
Если sw остановлен, а от него требуется выполнить работу, тогда браузер <ins>заново</ins> инициализирует sw.  
И вот такой цикл: Инициализация -> Останов -> Инициализация -> Останов -> Инициализация -> ... - является ***нормальным режимом*** работы sw.

- Рефреш страницы сам по себе по умолчанию никакого влияния на sw не производит, то есть, если обновить страницу, то переинциализации sw не произойдет;
- Если закрыть страницу, то какое-то время sw продолжит оставаться в активном состоянии;
- Если на момент открытия страницы(после закрытия) sw еще будет активен, то переинициализации sw не произойдет;
- Если браузер остановил sw, когда страница не закрыта (допустим сейчас пользователь переключился на другую закладку с другим сайтом), то активация закладки со страницей с остановленным sw по умолчанию не инициализирует sw. А вот когда пользователь выполнит действия на странице, которые потребуют наличие sw, то браузер его проинициализирует.

### Установка -> Ожидание -> Активация

#### 1. Первая установка

1. Браузер проведет первичную инициализацию sw.
2. Вызовет событие `install`. Если обработка события `install` не выбросила ошибку, тогда следующим сработает событие `activate` и при его успешном завершении sw перейдет в активное состояние – начнет слушать события: `fetch`, `message`, `push`, `sync` и др., и как-то на них реагировать.

#### 2. Обновление

Перед каждой попыткой инициализировать sw браузер скачивает `sw.js` и проверяет: "А не изменилось ли содержимое `sw.js`?".  
Если файл `sw.js` изменился, тогда браузер запустит процесс установки новой версии sw.

1. Проведет инициализацию текущей версии sw (ранее установленной).
2. Вызовет событие `install`, если обработка события `install` не выбросила ошибку, тогда новый sw переходит в режим ожидания до тех пор, пока текущая версия sw контроллирует хотя бы одного клиента. Как только таких клиентов не останется будет вызвано событие `activate` и после его успешного завершения новый sw перейдет в активное состояние.

Если выполнить команду `self.skipWaiting()`, тогда браузер пропустит этап ожидания и сразу после успешно завершенного события `install` вызовет событие `activate`.

#### Ошибки в процессе

Если при обработке событий `install`, `activate` произошла ошибка, тогда установка нового sw прервется.  
Браузер попытается заново запустить установку при следующей попытке инициализации sw.

#### Активного состояния недостаточно

На самом деле, когда новый sw переходит в активное состояние, клиенты о нем еще не знают. Это значит, например, что в событие `fetch` не будут прилетать сетевые запросы.  
Чтобы sw стал полностью работоспособным браузер должен привязать к нему клиентов, а для этого надо:

- либо рефрешнуть страницу(ы);
- либо выполнить `self.clients.claim()`.

# Особенности

### В одной закладке браузера событие 'fetch' всегда вызывается только на одном зарегистрированном sw

Scope sw доступен в `self.registration.scope` и всегда включает origin.  
Предположим на origin `http://localhost:2020` зарегистрировано два sw для scope `/` и `/banana/`, полностью их scope выглядят так:

- для sw#1 = `http://localhost:2020/`
- для sw#2 = `http://localhost:2020/banana/`

Браузер выбирает sw, основываясь на содержимом браузерной строки.  
Например, пользователь перешел по адресу `http://localhost:2020/banana/index.html`, значит браузер задействует sw#2, а следовательно **любая** сетевая активность пользователя начнет проходить через событие `fetch` sw#2, не важно захочет пользователь получить файл `/123.txt`, `/banana/123.txt` или `/какой/угодно/путь/123.txt`.  
Если пользователь в браузерной строке перейдет по пути `http://localhost:2020/banana-apple/index.html` или `http://localhost:2020/index.html`, тогда браузер задействует sw#1, потому что `/banana-apple/` и `/` подпадают только под scope `http://localhost:2020/`.

Для проверки можно воспользоваться: https://sw-fetch-is-not-limited-by-scope.github.io  
Там один sw на scope `/`, другой на scope `/banana`.  
Каждый sw логирует в консоль запросы, прошедшие через его событие `fetch`.

### Сервис воркер способен работать даже при недоступном сервере

Сервис воркер работает в браузере локально, даже если сейчас недоступен сервер, с которого он был получен.  
Например, sw был установлен с сайта https://my.site.ru.  
Далее вы берете и отключаете сетевое соединение.  
Закрываете браузер.  
Точно можно сказать, что сервис воркер(sw) инициализируется после действий:

- открыть браузер;
- открыть консоль sw: `chrome://serviceworker-internals`;
- в этот момент у всех sw браузера `Running Status: STOPPED`;
- перейти на сайт https://my.site.ru

Браузер вам говорит 'This site can’t be reached', но в консоле у sw сайта `Running Status: RUNNING`.   
В хроме при таких условиях через 30 секунд его статус сменится на `STOPPED`.    
Затем, если вкладка остается активной, то хром самостоятельно попытается его проинициализировать через: 1 мин., 1 мин., 1 мин., 4 мин. - но не могу сказать будет он дальше предпринимать попытки инициализации или нет.

### Вместо 404 сайт отвечает 200+html с описанием ошибки

На все данные, что мы хотим кешировать, сервер(если эти данные у него отсутствуют) должен возвращать корректную ошибку в HTTP status code.  
В противном случае, если сервер при отсутствии данных отдает, например, статус 200 + html страницу, где сообщается, что произошла такая-то ошибка, тогда в кеш вместо ожидаемого файла попадет эта самая страница. Соответственно, когда браузер вместо, скажем, шрифта получает из кеша содержимое html страницы, то приложение будет работать непредсказуемо.  
Варианты решения:

- лучше всего, чтобы сервер при ошибке отвечал одним из статусов ошибки, например, 404;
- положить файл в нужное место -> обновить sw.js, чтобы активировать на клиентах обновление кеша(т.к. кривота уже сохранена в кеше и появление файла на сервере не решит проблему);
- реализовать прекеш с привязкой к Content-Type, если не тот что ожидатся - не кешировать файл.

### Обновление в chrome

В хроме иногда наблюдается следующая последовательность обновления:

- качается новая версия sw файла
- хром чего-то ждет **ровно** 5 минут
- запускает цикл обновления

# События

### `install`

Здесь можно сделать прекеш. При отсутствии прекеша следующая загрузка приложения(сразу после установки/обновления) стартует как если бы кеша нет - все качается по сети - то есть смысл в том, что **не быстро**. А уже после рефреша страницы из кеша.

### `activate`

Здесь можно почистить кеш.

### `fetch`

Сюда браузер заворачивает все запросы пользователя: `GET`, `POST`, `PUT`, `HEAD`, `DELETE`, `PATCH`, `OPTIONS`.  
Для кеширующего sw наверное есть смысл обрабатывать только `GET`.

### `message`

Обмен сообщениями между sw и его клиентами.

### `push`

### `sync`

# Ссылки

[Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)  
[Recipes by Google](https://googlechrome.github.io/samples/service-worker/)  
[Cookbook by Mozilla](https://serviceworke.rs/)

### Jake Archibald

- [Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle)
- [The Offline Cookbook](https://web.dev/offline-cookbook/)
- [Different versions of your site can be running at the same time](https://jakearchibald.com/2020/multiple-versions-same-time/)
- [Service workers and base URIs](https://jakearchibald.com/2016/service-workers-and-base-uris/)
- [Speed up Service Worker with Navigation Preloads](https://developers.google.com/web/updates/2017/02/navigation-preload)

### Progressive Web Apps Training

- [Introduction to Service Worker](https://developers.google.com/web/ilt/pwa/introduction-to-service-worker)
- [Lab: Scripting the Service Worker](https://developers.google.com/web/ilt/pwa/lab-scripting-the-service-worker)
- [Live Data in the Service Worker](https://developers.google.com/web/ilt/pwa/live-data-in-the-service-worker)
- [Caching Files with Service Worker](https://developers.google.com/web/ilt/pwa/caching-files-with-service-worker)

### sw cache vs HTTP cache

- [Prevent unnecessary network requests with the HTTP Cache](https://web.dev/http-cache/)

### habr

- [Service Workers. Инструкция по применению](https://habr.com/ru/company/2gis/blog/345552/)
- [Обновление вашего PWA в продакшене](https://habr.com/ru/post/535428/)
- [Как мы запустили offline-версию сайта RG.RU](https://habr.com/ru/company/oleg-bunin/blog/348150/)
- [Подводные камни Service Workers(когда надо использовать IndexedDB)](https://habr.com/ru/post/351194/)

[Service workers and the Cache Storage API](https://web.dev/service-workers-cache-storage/)
